{"name":"FRHTTP","tagline":"A NodeJS framework that allows developers to write HTTP endpoints in a functional reactive way.","body":"FRHTTP\r\n=========\r\n\r\n> Simplicity is prerequisite for reliability.\r\n>\r\n> <sup><sub>-Edsger W. Dijkstra</sub></sup>\r\n\r\nFRHTTP is a backend web framework designed to facilitate the development of functional reactive web services/sites.\r\n\r\n## Key benefits: ##\r\n* eliminates callback hell\r\n* easy to reason about\r\n* easier to test (since functions can be tested in isolation)\r\n* facilitates code reuse (potentially even with your frontend)\r\n* can be used either standalone or as part of your existing Express project\r\n\r\n## Install ##\r\n\r\n```\r\nnpm install frhttp\r\n```\r\n\r\n## Quick Start ##\r\n```js\r\nvar FRHTTP = require('frhttp');\r\n\r\nvar server = FRHTTP.createServer();\r\n\r\nserver.GET('/hello').onValue(function (route) {\r\n  route.process.when({\r\n    name: 'hello_world'\r\n    params: [],\r\n    produces: ['message'],\r\n    fn: function (produce, input) {\r\n      produce.value('message', 'hello, world');\r\n      produce.done();\r\n    }\r\n  }).render({\r\n    params: ['message'];\r\n    fn: function (writer, input) {\r\n      writer.writeBody(input.message);\r\n    }\r\n  });\r\n});\r\n\r\nserver.listen(8000);\r\n```\r\n\r\n## User Guide ##\r\n\r\n### Creating a server ###\r\n\r\nTo create a server, import the FRHTTP library and call createServer.  The call should look something like this:\r\n\r\n```js\r\nvar server = require('frhttp').createServer();\r\n```\r\n\r\n### Defining a route ###\r\n\r\nDefining routes in FRHTTP is relatively easy.  Routes are separated by HTTP verbs (GET, POST, PUT, DELETE) and can be created or retrieved via similarly named methods when the server object.  The method calls return a stream (in usage here, conceptually similar to a promise) with an onValue method.  The onValue method takes a function which will receive the route.  Once you have the route you can set up the process functions as well as the render function.  Lets look at some code:\r\n\r\n```js\r\nserver.GET('/api/isSquareRoot/:number/:possibleSqrt').onValue(function (route) {\r\n\troute.process.when({\r\n\t\tname: 'doubleIt',\r\n\t\tparams: [server.CONSTANTS.URL_VARS],\r\n\t\tproduces: ['sqrtToPow2'],\r\n\t\tfn: function(produce, input) {\r\n\t\t\tvar possibleSqrt = +input[server.CONSTANTS.URL_VARS].possibleSqrt;\r\n\t\t\tproduce.value('sqrtToPow2', possibleSqrt*possibleSqrt);\r\n\t\t\tproduce.done();\r\n\t\t}\r\n\t}).when({\r\n\t\tname: 'checkIt',\r\n\t\tparams: [server.CONSTANTS.URL_VARS, 'sqrtToPow2'],\r\n\t\tproduces: ['passed'],\r\n\t\tfn: function(produce, input) {\r\n\t\t\tvar checkNum = +input[server.CONSTANTS.URL_VARS].number;\r\n\t\t\tproduce.value('passed', input.sqrtToPow2 === +checkNum);\r\n\t\t\tproduce.done();\r\n\t\t}\r\n\t}).render({\r\n\t\tparams: [server.CONSTANTS.URL_VARS, 'passed'],\r\n\t\tfn: function(writer, input) {\r\n\t\t\tvar num = input[server.CONSTANTS.URL_VARS].number,\r\n\t\t\t\tpossibleSqrt = input[server.CONSTANTS.URL_VARS].possibleSqrt;\r\n\t\t\tif (input.passed) {\r\n\t\t\t\twriter.writeBody(possibleSqrt + ' is the square root of ' + num);\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\twriter.writeBody(possibleSqrt + ' is not the square root of ' + num);\r\n\t\t\t}\r\n\t\t}\r\n\t});\r\n});\r\n```\r\n\r\nA couple of things to note before we get started on analyzing what's going on here.  First, the + in front of a variable such as on this line ```var possibleSqrt = +input[server.CONSTANTS.URL_VARS].possibleSqrt;``` converts whatever that field is to a number so we can do math operations on it.  Second, for illustrative purposes, we've intentionally taken a very long (horribly non-optimal) approach to figuring out if a number is the sqrt of another.\r\n\r\nLets analyze this code from the top.  First we see that we're configuring a GET route at `/api/isSquareRoot/:number/:possibleSqrt`.  The parts of the URL here with the `:` in front are \"url variables\".  This means that in our real URL, they'll be something else, but the frhttp executor will extract them for us into a field from which we can get a nice mapping from what we have here to what actually appeared in the URL.  We'll see this a few lines down.\r\n\r\nRecall from earlier we mentioned that the GET (and in fact any server function other than listen) returns a stream.  We call the onValue method of that stream to get our actual route for configuration.\r\n\r\nOnce we have our route we can start configuring it.  A route has 2 phases, `process` and `render`.  In the process phase, we set up functions to be called when data is ready.  To do this, we use the `on` method of process.  Note that `when` is chainable so we don't need to keep calling `route.process`.  `when` takes a function definition object.  Here's what that object contains:\r\n\r\nfield | required | description\r\n------|----------|---------------\r\nname | No | the name of the function, used for debugging and error reporting purposes. While this is optional it's highly recommended. \r\nparams | No | the parameters you require.  These will be passed to you as an object to the second parameter to your function.  If you don't require any parameters you can omit this field.\r\nproduces | No | the parameters your function produces.\r\nfn | Yes | the function to execute when all the parameters are ready.\r\nenter exit, inject, takeMany | No | parameters for advanced usage described in the API section below\r\n\r\nOur first when definition expects the url variables, and produces a field called `sqrtToPow2`, our second when definition (the order doesn't matter here, it would work just fine to make this the first function) takes the url variables and `sqrtToPow2` as inputs and produces a field called `passed`.  Finally our render function takes the url variables and `passed` as inputs to write out the result.\r\n\r\nThe function in the when definition takes 2 parameters.  First is the producer.  This has 3 methods:\r\n```js\r\n{\r\n  value: function (name, value),\r\n  done: function (),\r\n  error: function(httpErrorCode, description)\r\n}\r\n```\r\nYou may call value to produce any values you have declared.  You may produce the same value multiple times (such as accepting an array and then producing each element as an individual value), and you may do so synchronously or asynchronously but you *MUST* call done once you've produced all the values you are going to produce.  You may *NOT* produce values you have not declared.\r\n\r\nThe render definition is quite similar to the process definition but for 2 factors.  First, there's only ever 1 render function, so there's no `when` method.  Second the first parameter to the render function is a writer not a producer.  The render function will always be called once no more producers can run unless there was an error.  Any parameters which aren't available but are requested by the render function will be present but null.  The writer has the following signature:\r\n```js\r\n{\r\n  writeBody: function(body),\r\n  writePartial: function(chunk),\r\n  setHeader: function(name, value),\r\n  setCookie: function(name, value),\r\n  setStatus: function(statusCode),\r\n  done: function()\r\n}\r\n```\r\n\r\nIf you just want to write a JSON, HTML or text payload, writeBody does all the work necessary.  If you need to write something more complex (transmit a binary file for example), then you can use writePartial.  If you do *NOT* use `writeBody` you *MUST* set your own headers (Content-Length, etc) and you *MUST* call done.  If your render function is called, the status defaults to 200.  If you would like to send an alternative status (such as for a redirect), you should call setStatus before calling any write function.\r\n\r\nWhen this route executes, the system will run any functions that can run with available data.  In this case, that's the first `when` function because the url variables are ready.  The second function can't run because even though the url variables are ready, `sqrtToPow2` is not. Once the first function runs, it produces `sqrtToPow2`.  This allows the second function to run.  The run will proceed in this fashion until no more functions can be called based on the available data.  At this point the system will call the render function and produce output.\r\n\r\n### Starting the server in standalone mode ###\r\n\r\nStarting is standalone mode is quite simple.  Just run the listen method on the server with a port number like so:\r\n```js\r\nserver.listen(8000); //8000 can be replaced with any valid and available port number\r\n```\r\n\r\n### Using as part of an Express/Connect/Etc app ###\r\n\r\nUsing a FRHTTP route in an Express/Connect app is only slightly more work than standalone mode.  Lets assume that your Express app is in the variable `app` and your FRHTTP server is in a variable called `server`.  The following code would execute a route on a get call:\r\n```js\r\napp.get('/api/doSomething', function(req, res) {\r\n  server.TAP_GET('/api/doSomething').onValue(function (executor) {\r\n    var url = require('url').parse(req.url);\r\n    executor.execute(url, req, res, executor.inject);\r\n  });\r\n});\r\n```\r\n\r\n## API Guide ##\r\n\r\n### createServer() ###\r\n\r\nReturns a server object.  You can either use this directly or as part of an Express app as described below.\r\n\r\n### Server Object ###\r\n\r\nThe server object exposes a number of methods related to registering and finding routes as well as several constants under the CONSTANTS field.  The server supports hanging routes off the 4 main REST verbs:\r\n```js\r\nGET(path)\r\nPOST(path)\r\nPUT(path)\r\nDELETE(path)\r\n```\r\nTo achieve this, one would create a server like so:\r\n```js \r\nserver = require('frhttp').createServer(); \r\n```\r\n\r\nThen call the verb on the server like so: \r\n```js\r\nserver.GET(/* your path here such as /api/client */).onValue(function (route) {\r\n  // define your route here as explained below\r\n});\r\n```\r\n\r\nThe server object also supports finding existing routes for execution (in case you're adding this to an existing Express app).  These can be found at TAP_{VERB}:\r\n```js\r\nTAP_GET(path)\r\nTAP_POST(path)\r\nTAP_PUT(path)\r\nTAP_DELETE(path)\r\n```\r\nYou can look up a route like so:\r\n```js\r\nserver.TAP_GET(/* some url */).onValue(function (executor) {\r\n  //execute the route here as explained below\r\n})\r\n```\r\nThe last method on the Server object is the `listen` method.  \r\n```js\r\nlisten(portNumber)\r\n```\r\nThe single parameter to this method is a port number to bind to.  If you plan to use FRHTTP along side Express (to handle some of the routes), you do not need to call listen.\r\n\r\n### Route configuration object ###\r\n\r\nThe route configuration object is passed to the onValue function for every configuration function on the Server object (GET, POST, PUT, DELETE).  The object exposes the `process` property and a `render` config function.  The `process` property exposes the following properties and methods:\r\n\r\nField | Description\r\n------|------------\r\nwhen(def) | Connects a function to the route via the def object (described below).  Returns the process object so you can chain calls\r\ninject(obj) | Allows you to preset fields needed by functions.  The obj should be a POJO (plain old javascript object).  Returns the process object so you can chain calls\r\nparseBody() | Parses the body into a field you can access by requesting server.CONSTANTS.REQUEST_BODY.  Returns the process object so you can chain calls.  You should attach this no more than once (you can skip it if you either don't need the body or prefer to parse it yourself).  Calling this function multiple times may result in strange behavior.\r\nrender(def) | Defines the render function.  The def object is described below.  Returns undefined.  This should be the last method you call in setting up a chain and should only be called once.  Multiple calls to this method will replace the previous definition with the one in the latest call.\r\n\r\n`process.when` definition object\r\n\r\nfield | required | description\r\n------|----------|---------------\r\nname | No | the name of the function, used for debugging and error reporting purposes. While this is optional it's highly recommended. \r\nparams | No | the parameters you require.  These will be passed to you as an object to the second parameter to your function.  If you don't require any parameters you can omit this field.\r\nproduces | No | the parameters your function produces.\r\nfn | Yes | the function to execute when all the parameters are ready.\r\nenter | No | a function that will be called with the parameter object prior to calling fn.  The value returned from the enter function is passed to fn.  To prevent fn from being called return undefined from the enter function (allowing enter to be used as a filter function).\r\nexit | No | a function called after each value produced by fn.  The value returned by exit will be published instead of the value produced by fn.\r\ntakeMany | No | false by default.  If set to true, fn can be called each time params are available, otherwise fn will only be called the first time params are available.\r\n\r\nOne way to consider enter, fn and exit are: \r\n```js\r\nstream.map(enter).flatMap(fn).map(exit)\r\n```\r\n\r\n`fn` signature:\r\n```js\r\nfunction fn(produce, input)\r\n```\r\n\r\n`produce` object:\r\n```js\r\n{\r\n  value: function (name, value), // name: name of field to produce, value: value\r\n  done: function (),\r\n  error: function(httpErrorCode, description)\r\n}\r\n```\r\n\r\n`render` definition object\r\n\r\nfield | required | description\r\n------|----------|---------------\r\nparams | Yes | the parameters you require.  These will be passed to you as an object to the second parameter to your function.  Any value not produced during the process phase will be set to null in the second parameter to fn.\r\nfn | Yes | the function to execute when all the parameters are ready.\r\n\r\n`fn` signature:\r\n```js\r\nfunction fn(writer, input)\r\n```\r\n\r\n`writer` object:\r\n```js\r\n{\r\n  writeBody: function(body),\r\n  writePartial: function(chunk),\r\n  setHeader: function(name, value),\r\n  setCookie: function(name, value),\r\n  setStatus: function(statusCode),\r\n  done: function()\r\n}\r\n```\r\n\r\n### Route executor object ###\r\n\r\nIf you plan to use frhttp via the listen method and not as part of an Express app, you do not need to worry about the route executor object.  \r\n\r\n## Roadmap ##\r\n\r\n* Tests\r\n* More docs\r\n* Demonstrate how to integrate with PassportJS\r\n* Samples folder\r\n* Websocket support\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}