<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <link href='https://fonts.googleapis.com/css?family=Architects+Daughter' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/pygment_trac.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/print.css" media="print">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <title>FRHTTP by ayasin</title>
  </head>

  <body>
    <header>
      <div class="inner">
        <h1>FRHTTP</h1>
        <h2>A NodeJS framework that allows developers to write HTTP endpoints in a functional reactive way.</h2>
        <a href="https://github.com/ayasin/frhttp" class="button"><small>View project on</small> GitHub</a>
      </div>
    </header>

    <div id="content-wrapper">
      <div class="inner clearfix">
        <section id="main-content">
          <h1>
<a id="frhttp" class="anchor" href="#frhttp" aria-hidden="true"><span class="octicon octicon-link"></span></a>FRHTTP</h1>

<blockquote>
<p>Simplicity is prerequisite for reliability.</p>

<p><sup><sub>-Edsger W. Dijkstra</sub></sup></p>
</blockquote>

<p>FRHTTP is a backend web framework designed to facilitate the development of functional reactive web services/sites.</p>

<h2>
<a id="key-benefits" class="anchor" href="#key-benefits" aria-hidden="true"><span class="octicon octicon-link"></span></a>Key benefits:</h2>

<ul>
<li>eliminates callback hell</li>
<li>easy to reason about</li>
<li>easier to test (since functions can be tested in isolation)</li>
<li>facilitates code reuse (potentially even with your frontend)</li>
<li>can be used either standalone or as part of your existing Express project</li>
</ul>

<h2>
<a id="install" class="anchor" href="#install" aria-hidden="true"><span class="octicon octicon-link"></span></a>Install</h2>

<pre><code>npm install frhttp
</code></pre>

<h2>
<a id="quick-start" class="anchor" href="#quick-start" aria-hidden="true"><span class="octicon octicon-link"></span></a>Quick Start</h2>

<div class="highlight highlight-js"><pre><span class="pl-s">var</span> FRHTTP <span class="pl-k">=</span> <span class="pl-s3">require</span>(<span class="pl-s1"><span class="pl-pds">'</span>frhttp<span class="pl-pds">'</span></span>);

<span class="pl-s">var</span> server <span class="pl-k">=</span> FRHTTP.createServer();

server.GET(<span class="pl-s1"><span class="pl-pds">'</span>/hello<span class="pl-pds">'</span></span>).onValue(<span class="pl-st">function</span> (<span class="pl-vpf">route</span>) {
  route.process.when({
    name<span class="pl-k">:</span> <span class="pl-s1"><span class="pl-pds">'</span>hello_world<span class="pl-pds">'</span></span>
    params<span class="pl-k">:</span> [],
    produces<span class="pl-k">:</span> [<span class="pl-s1"><span class="pl-pds">'</span>message<span class="pl-pds">'</span></span>],
    <span class="pl-en">fn</span>: <span class="pl-st">function</span> (<span class="pl-vpf">produce</span>, <span class="pl-vpf">input</span>) {
      produce.<span class="pl-sc">value</span>(<span class="pl-s1"><span class="pl-pds">'</span>message<span class="pl-pds">'</span></span>, <span class="pl-s1"><span class="pl-pds">'</span>hello, world<span class="pl-pds">'</span></span>);
      produce.done();
    }
  }).render({
    params<span class="pl-k">:</span> [<span class="pl-s1"><span class="pl-pds">'</span>message<span class="pl-pds">'</span></span>];
    <span class="pl-en">fn</span>: <span class="pl-st">function</span> (<span class="pl-vpf">writer</span>, <span class="pl-vpf">input</span>) {
      writer.writeBody(input.message);
    }
  });
});

server.listen(<span class="pl-c1">8000</span>);</pre></div>

<h2>
<a id="user-guide" class="anchor" href="#user-guide" aria-hidden="true"><span class="octicon octicon-link"></span></a>User Guide</h2>

<h3>
<a id="creating-a-server" class="anchor" href="#creating-a-server" aria-hidden="true"><span class="octicon octicon-link"></span></a>Creating a server</h3>

<p>To create a server, import the FRHTTP library and call createServer.  The call should look something like this:</p>

<div class="highlight highlight-js"><pre><span class="pl-s">var</span> server <span class="pl-k">=</span> <span class="pl-s3">require</span>(<span class="pl-s1"><span class="pl-pds">'</span>frhttp<span class="pl-pds">'</span></span>).createServer();</pre></div>

<h3>
<a id="defining-a-route" class="anchor" href="#defining-a-route" aria-hidden="true"><span class="octicon octicon-link"></span></a>Defining a route</h3>

<p>Defining routes in FRHTTP is relatively easy.  Routes are separated by HTTP verbs (GET, POST, PUT, DELETE) and can be created or retrieved via similarly named methods when the server object.  The method calls return a stream (in usage here, conceptually similar to a promise) with an onValue method.  The onValue method takes a function which will receive the route.  Once you have the route you can set up the process functions as well as the render function.  Lets look at some code:</p>

<div class="highlight highlight-js"><pre>server.GET(<span class="pl-s1"><span class="pl-pds">'</span>/api/isSquareRoot/:number/:possibleSqrt<span class="pl-pds">'</span></span>).onValue(<span class="pl-st">function</span> (<span class="pl-vpf">route</span>) {
    route.process.when({
        name<span class="pl-k">:</span> <span class="pl-s1"><span class="pl-pds">'</span>doubleIt<span class="pl-pds">'</span></span>,
        params<span class="pl-k">:</span> [server.CONSTANTS.URL_VARS],
        produces<span class="pl-k">:</span> [<span class="pl-s1"><span class="pl-pds">'</span>sqrtToPow2<span class="pl-pds">'</span></span>],
        <span class="pl-en">fn</span>: <span class="pl-st">function</span>(<span class="pl-vpf">produce</span>, <span class="pl-vpf">input</span>) {
            <span class="pl-s">var</span> possibleSqrt <span class="pl-k">=</span> <span class="pl-k">+</span>input[server.CONSTANTS.URL_VARS].possibleSqrt;
            produce.<span class="pl-sc">value</span>(<span class="pl-s1"><span class="pl-pds">'</span>sqrtToPow2<span class="pl-pds">'</span></span>, possibleSqrt<span class="pl-k">*</span>possibleSqrt);
            produce.done();
        }
    }).when({
        name<span class="pl-k">:</span> <span class="pl-s1"><span class="pl-pds">'</span>checkIt<span class="pl-pds">'</span></span>,
        params<span class="pl-k">:</span> [server.CONSTANTS.URL_VARS, <span class="pl-s1"><span class="pl-pds">'</span>sqrtToPow2<span class="pl-pds">'</span></span>],
        produces<span class="pl-k">:</span> [<span class="pl-s1"><span class="pl-pds">'</span>passed<span class="pl-pds">'</span></span>],
        <span class="pl-en">fn</span>: <span class="pl-st">function</span>(<span class="pl-vpf">produce</span>, <span class="pl-vpf">input</span>) {
            <span class="pl-s">var</span> checkNum <span class="pl-k">=</span> <span class="pl-k">+</span>input[server.CONSTANTS.URL_VARS].number;
            produce.<span class="pl-sc">value</span>(<span class="pl-s1"><span class="pl-pds">'</span>passed<span class="pl-pds">'</span></span>, input.sqrtToPow2 <span class="pl-k">===</span> <span class="pl-k">+</span>checkNum);
            produce.done();
        }
    }).render({
        params<span class="pl-k">:</span> [server.CONSTANTS.URL_VARS, <span class="pl-s1"><span class="pl-pds">'</span>passed<span class="pl-pds">'</span></span>],
        <span class="pl-en">fn</span>: <span class="pl-st">function</span>(<span class="pl-vpf">writer</span>, <span class="pl-vpf">input</span>) {
            <span class="pl-s">var</span> num <span class="pl-k">=</span> input[server.CONSTANTS.URL_VARS].number,
                possibleSqrt <span class="pl-k">=</span> input[server.CONSTANTS.URL_VARS].possibleSqrt;
            <span class="pl-k">if</span> (input.passed) {
                writer.writeBody(possibleSqrt <span class="pl-k">+</span> <span class="pl-s1"><span class="pl-pds">'</span> is the square root of <span class="pl-pds">'</span></span> <span class="pl-k">+</span> num);
            }
            <span class="pl-k">else</span> {
                writer.writeBody(possibleSqrt <span class="pl-k">+</span> <span class="pl-s1"><span class="pl-pds">'</span> is not the square root of <span class="pl-pds">'</span></span> <span class="pl-k">+</span> num);
            }
        }
    });
});</pre></div>

<p>A couple of things to note before we get started on analyzing what's going on here.  First, the + in front of a variable such as on this line <code>var possibleSqrt = +input[server.CONSTANTS.URL_VARS].possibleSqrt;</code> converts whatever that field is to a number so we can do math operations on it.  Second, for illustrative purposes, we've intentionally taken a very long (horribly non-optimal) approach to figuring out if a number is the sqrt of another.</p>

<p>Lets analyze this code from the top.  First we see that we're configuring a GET route at <code>/api/isSquareRoot/:number/:possibleSqrt</code>.  The parts of the URL here with the <code>:</code> in front are "url variables".  This means that in our real URL, they'll be something else, but the frhttp executor will extract them for us into a field from which we can get a nice mapping from what we have here to what actually appeared in the URL.  We'll see this a few lines down.</p>

<p>Recall from earlier we mentioned that the GET (and in fact any server function other than listen) returns a stream.  We call the onValue method of that stream to get our actual route for configuration.</p>

<p>Once we have our route we can start configuring it.  A route has 2 phases, <code>process</code> and <code>render</code>.  In the process phase, we set up functions to be called when data is ready.  To do this, we use the <code>on</code> method of process.  Note that <code>when</code> is chainable so we don't need to keep calling <code>route.process</code>.  <code>when</code> takes a function definition object.  Here's what that object contains:</p>

<table>
<thead>
<tr>
<th>field</th>
<th>required</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td>name</td>
<td>No</td>
<td>the name of the function, used for debugging and error reporting purposes. While this is optional it's highly recommended.</td>
</tr>
<tr>
<td>params</td>
<td>No</td>
<td>the parameters you require.  These will be passed to you as an object to the second parameter to your function.  If you don't require any parameters you can omit this field.</td>
</tr>
<tr>
<td>produces</td>
<td>No</td>
<td>the parameters your function produces.</td>
</tr>
<tr>
<td>fn</td>
<td>Yes</td>
<td>the function to execute when all the parameters are ready.</td>
</tr>
<tr>
<td>enter exit, inject, takeMany</td>
<td>No</td>
<td>parameters for advanced usage described in the API section below</td>
</tr>
</tbody>
</table>

<p>Our first when definition expects the url variables, and produces a field called <code>sqrtToPow2</code>, our second when definition (the order doesn't matter here, it would work just fine to make this the first function) takes the url variables and <code>sqrtToPow2</code> as inputs and produces a field called <code>passed</code>.  Finally our render function takes the url variables and <code>passed</code> as inputs to write out the result.</p>

<p>The function in the when definition takes 2 parameters.  First is the producer.  This has 3 methods:</p>

<div class="highlight highlight-js"><pre>{
  <span class="pl-en">value</span>: <span class="pl-st">function</span> (<span class="pl-vpf">name</span>, <span class="pl-vpf">value</span>),
  <span class="pl-en">done</span>: <span class="pl-st">function</span> (),
  <span class="pl-en">error</span>: <span class="pl-st">function</span>(<span class="pl-vpf">httpErrorCode</span>, <span class="pl-vpf">description</span>)
}</pre></div>

<p>You may call value to produce any values you have declared.  You may produce the same value multiple times (such as accepting an array and then producing each element as an individual value), and you may do so synchronously or asynchronously but you <em>MUST</em> call done once you've produced all the values you are going to produce.  You may <em>NOT</em> produce values you have not declared.</p>

<p>The render definition is quite similar to the process definition but for 2 factors.  First, there's only ever 1 render function, so there's no <code>when</code> method.  Second the first parameter to the render function is a writer not a producer.  The render function will always be called once no more producers can run unless there was an error.  Any parameters which aren't available but are requested by the render function will be present but null.  The writer has the following signature:</p>

<div class="highlight highlight-js"><pre>{
  <span class="pl-en">writeBody</span>: <span class="pl-st">function</span>(<span class="pl-vpf">body</span>),
  <span class="pl-en">writePartial</span>: <span class="pl-st">function</span>(<span class="pl-vpf">chunk</span>),
  <span class="pl-en">setHeader</span>: <span class="pl-st">function</span>(<span class="pl-vpf">name</span>, <span class="pl-vpf">value</span>),
  <span class="pl-en">setCookie</span>: <span class="pl-st">function</span>(<span class="pl-vpf">name</span>, <span class="pl-vpf">value</span>),
  <span class="pl-en">setStatus</span>: <span class="pl-st">function</span>(<span class="pl-vpf">statusCode</span>),
  <span class="pl-en">done</span>: <span class="pl-st">function</span>()
}</pre></div>

<p>If you just want to write a JSON, HTML or text payload, writeBody does all the work necessary.  If you need to write something more complex (transmit a binary file for example), then you can use writePartial.  If you do <em>NOT</em> use <code>writeBody</code> you <em>MUST</em> set your own headers (Content-Length, etc) and you <em>MUST</em> call done.  If your render function is called, the status defaults to 200.  If you would like to send an alternative status (such as for a redirect), you should call setStatus before calling any write function.</p>

<p>When this route executes, the system will run any functions that can run with available data.  In this case, that's the first <code>when</code> function because the url variables are ready.  The second function can't run because even though the url variables are ready, <code>sqrtToPow2</code> is not. Once the first function runs, it produces <code>sqrtToPow2</code>.  This allows the second function to run.  The run will proceed in this fashion until no more functions can be called based on the available data.  At this point the system will call the render function and produce output.</p>

<h3>
<a id="starting-the-server-in-standalone-mode" class="anchor" href="#starting-the-server-in-standalone-mode" aria-hidden="true"><span class="octicon octicon-link"></span></a>Starting the server in standalone mode</h3>

<p>Starting is standalone mode is quite simple.  Just run the listen method on the server with a port number like so:</p>

<div class="highlight highlight-js"><pre>server.listen(<span class="pl-c1">8000</span>); <span class="pl-c">//8000 can be replaced with any valid and available port number</span></pre></div>

<h3>
<a id="using-as-part-of-an-expressconnectetc-app" class="anchor" href="#using-as-part-of-an-expressconnectetc-app" aria-hidden="true"><span class="octicon octicon-link"></span></a>Using as part of an Express/Connect/Etc app</h3>

<p>Using a FRHTTP route in an Express/Connect app is only slightly more work than standalone mode.  Lets assume that your Express app is in the variable <code>app</code> and your FRHTTP server is in a variable called <code>server</code>.  The following code would execute a route on a get call:</p>

<div class="highlight highlight-js"><pre>app.get(<span class="pl-s1"><span class="pl-pds">'</span>/api/doSomething<span class="pl-pds">'</span></span>, <span class="pl-st">function</span>(<span class="pl-vpf">req</span>, <span class="pl-vpf">res</span>) {
  server.TAP_GET(<span class="pl-s1"><span class="pl-pds">'</span>/api/doSomething<span class="pl-pds">'</span></span>).onValue(<span class="pl-st">function</span> (<span class="pl-vpf">executor</span>) {
    <span class="pl-s">var</span> url <span class="pl-k">=</span> <span class="pl-s3">require</span>(<span class="pl-s1"><span class="pl-pds">'</span>url<span class="pl-pds">'</span></span>).<span class="pl-s3">parse</span>(req.url);
    executor.execute(url, req, res, executor.inject);
  });
});</pre></div>

<h2>
<a id="api-guide" class="anchor" href="#api-guide" aria-hidden="true"><span class="octicon octicon-link"></span></a>API Guide</h2>

<h3>
<a id="createserver" class="anchor" href="#createserver" aria-hidden="true"><span class="octicon octicon-link"></span></a>createServer()</h3>

<p>Returns a server object.  You can either use this directly or as part of an Express app as described below.</p>

<h3>
<a id="server-object" class="anchor" href="#server-object" aria-hidden="true"><span class="octicon octicon-link"></span></a>Server Object</h3>

<p>The server object exposes a number of methods related to registering and finding routes as well as several constants under the CONSTANTS field.  The server supports hanging routes off the 4 main REST verbs:</p>

<div class="highlight highlight-js"><pre>GET(path)
POST(path)
PUT(path)
DELETE(path)</pre></div>

<p>To achieve this, one would create a server like so:</p>

<div class="highlight highlight-js"><pre>server <span class="pl-k">=</span> <span class="pl-s3">require</span>(<span class="pl-s1"><span class="pl-pds">'</span>frhttp<span class="pl-pds">'</span></span>).createServer(); </pre></div>

<p>Then call the verb on the server like so: </p>

<div class="highlight highlight-js"><pre>server.GET(<span class="pl-c">/* your path here such as /api/client */</span>).onValue(<span class="pl-st">function</span> (<span class="pl-vpf">route</span>) {
  <span class="pl-c">// define your route here as explained below</span>
});</pre></div>

<p>The server object also supports finding existing routes for execution (in case you're adding this to an existing Express app).  These can be found at TAP_{VERB}:</p>

<div class="highlight highlight-js"><pre>TAP_GET(path)
TAP_POST(path)
TAP_PUT(path)
TAP_DELETE(path)</pre></div>

<p>You can look up a route like so:</p>

<div class="highlight highlight-js"><pre>server.TAP_GET(<span class="pl-c">/* some url */</span>).onValue(<span class="pl-st">function</span> (<span class="pl-vpf">executor</span>) {
  <span class="pl-c">//execute the route here as explained below</span>
})</pre></div>

<p>The last method on the Server object is the <code>listen</code> method.  </p>

<div class="highlight highlight-js"><pre>listen(portNumber)</pre></div>

<p>The single parameter to this method is a port number to bind to.  If you plan to use FRHTTP along side Express (to handle some of the routes), you do not need to call listen.</p>

<h3>
<a id="route-configuration-object" class="anchor" href="#route-configuration-object" aria-hidden="true"><span class="octicon octicon-link"></span></a>Route configuration object</h3>

<p>The route configuration object is passed to the onValue function for every configuration function on the Server object (GET, POST, PUT, DELETE).  The object exposes the <code>process</code> property and a <code>render</code> config function.  The <code>process</code> property exposes the following properties and methods:</p>

<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>when(def)</td>
<td>Connects a function to the route via the def object (described below).  Returns the process object so you can chain calls</td>
</tr>
<tr>
<td>inject(obj)</td>
<td>Allows you to preset fields needed by functions.  The obj should be a POJO (plain old javascript object).  Returns the process object so you can chain calls</td>
</tr>
<tr>
<td>parseBody()</td>
<td>Parses the body into a field you can access by requesting server.CONSTANTS.REQUEST_BODY.  Returns the process object so you can chain calls.  You should attach this no more than once (you can skip it if you either don't need the body or prefer to parse it yourself).  Calling this function multiple times may result in strange behavior.</td>
</tr>
<tr>
<td>render(def)</td>
<td>Defines the render function.  The def object is described below.  Returns undefined.  This should be the last method you call in setting up a chain and should only be called once.  Multiple calls to this method will replace the previous definition with the one in the latest call.</td>
</tr>
</tbody>
</table>

<p><code>process.when</code> definition object</p>

<table>
<thead>
<tr>
<th>field</th>
<th>required</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td>name</td>
<td>No</td>
<td>the name of the function, used for debugging and error reporting purposes. While this is optional it's highly recommended.</td>
</tr>
<tr>
<td>params</td>
<td>No</td>
<td>the parameters you require.  These will be passed to you as an object to the second parameter to your function.  If you don't require any parameters you can omit this field.</td>
</tr>
<tr>
<td>produces</td>
<td>No</td>
<td>the parameters your function produces.</td>
</tr>
<tr>
<td>fn</td>
<td>Yes</td>
<td>the function to execute when all the parameters are ready.</td>
</tr>
<tr>
<td>enter</td>
<td>No</td>
<td>a function that will be called with the parameter object prior to calling fn.  The value returned from the enter function is passed to fn.  To prevent fn from being called return undefined from the enter function (allowing enter to be used as a filter function).</td>
</tr>
<tr>
<td>exit</td>
<td>No</td>
<td>a function called after each value produced by fn.  The value returned by exit will be published instead of the value produced by fn.</td>
</tr>
<tr>
<td>takeMany</td>
<td>No</td>
<td>false by default.  If set to true, fn can be called each time params are available, otherwise fn will only be called the first time params are available.</td>
</tr>
</tbody>
</table>

<p>One way to consider enter, fn and exit are: </p>

<div class="highlight highlight-js"><pre>stream.map(enter).flatMap(fn).map(exit)</pre></div>

<p><code>fn</code> signature:</p>

<div class="highlight highlight-js"><pre><span class="pl-st">function</span> <span class="pl-en">fn</span>(<span class="pl-vpf">produce</span>, <span class="pl-vpf">input</span>)</pre></div>

<p><code>produce</code> object:</p>

<div class="highlight highlight-js"><pre>{
  <span class="pl-en">value</span>: <span class="pl-st">function</span> (<span class="pl-vpf">name</span>, <span class="pl-vpf">value</span>), <span class="pl-c">// name: name of field to produce, value: value</span>
  <span class="pl-en">done</span>: <span class="pl-st">function</span> (),
  <span class="pl-en">error</span>: <span class="pl-st">function</span>(<span class="pl-vpf">httpErrorCode</span>, <span class="pl-vpf">description</span>)
}</pre></div>

<p><code>render</code> definition object</p>

<table>
<thead>
<tr>
<th>field</th>
<th>required</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td>params</td>
<td>Yes</td>
<td>the parameters you require.  These will be passed to you as an object to the second parameter to your function.  Any value not produced during the process phase will be set to null in the second parameter to fn.</td>
</tr>
<tr>
<td>fn</td>
<td>Yes</td>
<td>the function to execute when all the parameters are ready.</td>
</tr>
</tbody>
</table>

<p><code>fn</code> signature:</p>

<div class="highlight highlight-js"><pre><span class="pl-st">function</span> <span class="pl-en">fn</span>(<span class="pl-vpf">writer</span>, <span class="pl-vpf">input</span>)</pre></div>

<p><code>writer</code> object:</p>

<div class="highlight highlight-js"><pre>{
  <span class="pl-en">writeBody</span>: <span class="pl-st">function</span>(<span class="pl-vpf">body</span>),
  <span class="pl-en">writePartial</span>: <span class="pl-st">function</span>(<span class="pl-vpf">chunk</span>),
  <span class="pl-en">setHeader</span>: <span class="pl-st">function</span>(<span class="pl-vpf">name</span>, <span class="pl-vpf">value</span>),
  <span class="pl-en">setCookie</span>: <span class="pl-st">function</span>(<span class="pl-vpf">name</span>, <span class="pl-vpf">value</span>),
  <span class="pl-en">setStatus</span>: <span class="pl-st">function</span>(<span class="pl-vpf">statusCode</span>),
  <span class="pl-en">done</span>: <span class="pl-st">function</span>()
}</pre></div>

<h3>
<a id="route-executor-object" class="anchor" href="#route-executor-object" aria-hidden="true"><span class="octicon octicon-link"></span></a>Route executor object</h3>

<p>If you plan to use frhttp via the listen method and not as part of an Express app, you do not need to worry about the route executor object.  </p>

<h2>
<a id="roadmap" class="anchor" href="#roadmap" aria-hidden="true"><span class="octicon octicon-link"></span></a>Roadmap</h2>

<ul>
<li>Tests</li>
<li>More docs</li>
<li>Demonstrate how to integrate with PassportJS</li>
<li>Samples folder</li>
<li>Websocket support</li>
</ul>
        </section>

        <aside id="sidebar">
          <a href="https://github.com/ayasin/frhttp/zipball/master" class="button">
            <small>Download</small>
            .zip file
          </a>
          <a href="https://github.com/ayasin/frhttp/tarball/master" class="button">
            <small>Download</small>
            .tar.gz file
          </a>

          <p class="repo-owner"><a href="https://github.com/ayasin/frhttp"></a> is maintained by <a href="https://github.com/ayasin">ayasin</a>.</p>

          <p>This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the Architect theme by <a href="https://twitter.com/jasonlong">Jason Long</a>.</p>
        </aside>
      </div>
    </div>

  
  </body>
</html>
